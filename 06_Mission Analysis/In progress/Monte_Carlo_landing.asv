%% Monte-Carlo autour du cas qui marche (reprend ton intégrateur tel quel)
clear; clc; rng('default');

%% ===== Paramètres généraux =====
g_moon = 1.62;          % m/s^2
dt      = 0.2;          % s
v_td    = -0.1;         % m/s visé en phase 3

% Propulsion/masse (200 kN pour respecter throttle<=95% sur le nominal)
params = struct( ...
  'g_moon', g_moon, 'Isp', 450, 'g0', 9.80665, ...
  'Tmax', 200e3, 'm0', 18000, 'm_dry', 11000, 'tilt_max_deg', 150);

%% ===== FIXES demandés =====
z0_fix  = 15e3;            % FIXE
vx0_fix = -1695;           % FIXE
x2_t = 0;  y2_t = 0;  z2_t = 100;    % FIXES phase 2
vx2_t = 0; vy2_t = 0; vz2_t = -8;    % FIXES phase 2
ax2_t = 0; ay2_t = 0; az2_t = 1.2*g_moon;
az3_cmd = 1.2*g_moon;

%% ===== Cas nominal (ton cas qui marche) =====
nom = struct();
nom.x0=300e3; nom.y0=0; nom.z0=z0_fix;
nom.vx0=vx0_fix; nom.vy0=0; nom.vz0=0;
nom.x1_t=25e3; nom.y1_t=0; nom.z1_t=5e3;
nom.vx1_t=-220; nom.vy1_t=0; nom.vz1_t=-45;
nom.x2_t=x2_t; nom.y2_t=y2_t; nom.z2_t=z2_t;
nom.vx2_t=vx2_t; nom.vy2_t=vy2_t; nom.vz2_t=vz2_t;
nom.ax2_t=ax2_t; nom.ay2_t=ay2_t; nom.az2_t=az2_t; nom.az3_cmd=az3_cmd;

[Tgo1_nom, Tgo2_nom] = phase_times(nom);
sim_nom = simulate_case(nom, params, dt);
out_nom = thrust_from_traj(sim_nom.t, [sim_nom.vx sim_nom.vy sim_nom.vz], params);

% === critères de succès (0,3%) ===
THR_MAX_OK = 0.95;
Sx=max([abs(nom.vx0),abs(nom.vx1_t),300]); Sy=max([abs(nom.vy1_t),100]); Sz=max([abs(nom.vz1_t),abs(nom.vz2_t),20]);
ok_nom = (abs(sim_nom.vx(end)) <= 0.003*Sx) && ...
         (abs(sim_nom.vy(end)) <= 0.003*Sy) && ...
         (abs(sim_nom.vz(end)-v_td) <= 0.003*Sz) && ...
         (max(out_nom.throttle) <= THR_MAX_OK) && ...
         all(max(out_nom.m-params.m_dry,0)(1:end-1) > 0);

fprintf('Nominal -> ok=%d | vx=%.3f vy=%.3f vz=%.3f | thrMax=%.1f%% | ΔV=%.1f\n', ...
    ok_nom, sim_nom.vx(end), sim_nom.vy(end), sim_nom.vz(end), 100*max(out_nom.throttle), out_nom.dV);

%% ===== Monte-Carlo (autour du nominal) =====
nMC = 500;

% variables A FAIRE VARIER (seuls z0,x2_t,y2_t,z2_t,vx0 restent FIXES)
PCT = struct('x0',0.03,'x1',0.10,'z1',0.10,'vx1',0.10,'vz1',0.10);
ABS = struct('y1',0,'vy1',0);   % ici 0 pour rester à y=0

cases = cell(nMC+1,1); sims = cell(nMC+1,1); outs = cell(nMC+1,1);
res = struct('success',false(nMC+1,1),'dv',nan(nMC+1,1),'thrmax',nan(nMC+1,1), ...
             'vx_td',nan(nMC+1,1),'vy_td',nan(nMC+1,1),'vz_td',nan(nMC+1,1), 't',nan(nMC+1,1));

% Insère le nominal en #1 (garantie d’avoir un cas qui “marche” physiquement)
cases{1}=nom; sims{1}=sim_nom; outs{1}=out_nom;
[ok1,dv1,thr1] = score_run(nom, sims{1}, outs{1}, v_td, THR_MAX_OK);
res.success(1)=ok1; res.dv(1)=dv1; res.thrmax(1)=thr1;
res.vx_td(1)=sim_nom.vx(end); res.vy_td(1)=sim_nom.vy(end); res.vz_td(1)=sim_nom.vz(end); res.t(1)=sim_nom.t(end);

for i=2:nMC+1
    s = nom;                                   % base
    s.x0   = vary_pct(nom.x0,  PCT.x0);
    s.y0   = nom.y0;
    s.z0   = z0_fix;                            % FIXE
    s.vx0  = vx0_fix;                           % FIXE
    s.vy0  = nom.vy0; s.vz0 = nom.vz0;

    s.x1_t = vary_pct(nom.x1_t, PCT.x1);
    s.y1_t = nom.y1_t + (2*rand-1)*ABS.y1;
    s.z1_t = vary_pct(nom.z1_t, PCT.z1);

    s.vx1_t= vary_pct(nom.vx1_t, PCT.vx1);
    s.vy1_t= nom.vy1_t + (2*rand-1)*ABS.vy1;
    s.vz1_t= vary_pct(nom.vz1_t, PCT.vz1);

    % Phase 2,3 restent FIXES (x2_t,y2_t,z2_t,vx2_t,vy2_t,vz2_t,az2_t,az3_cmd)

    sim = simulate_case(s, params, dt);
    out = thrust_from_traj(sim.t, [sim.vx sim.vy sim.vz], params);

    cases{i}=s; sims{i}=sim; outs{i}=out;
    [ok_i, dv_i, thr_i] = score_run(s, sim, out, v_td, THR_MAX_OK);
    res.success(i)=ok_i; res.dv(i)=dv_i; res.thrmax(i)=thr_i;
    res.vx_td(i)=sim.vx(end); res.vy_td(i)=sim.vy(end); res.vz_td(i)=sim.vz(end); res.t(i)=sim.t(end);
end

okIdx = find(res.success);
fprintf('MC: %d/%d succès (%.1f%%)\n', numel(okIdx), numel(res.success), 100*numel(okIdx)/numel(res.success));

if ~isempty(okIdx)
    [~,k] = min(res.dv(okIdx)); best = okIdx(k);
else
    [~,best] = min(res.dv);   % aucun succès: meilleur ΔV “proche”
end

fprintf('Best case: run %d | ΔV=%.1f | thrMax=%.1f%% | v_td=[%.3f %.3f %.3f] | t=%.1fs\n', ...
    best, res.dv(best), 100*res.thrmax(best), res.vx_td(best), res.vy_td(best), res.vz_td(best), res.t(best));

% ---- Petits plots sur le meilleur cas
bs = sims{best}; bo = outs{best};
figure('Name','Best case'); tiledlayout(2,2,'Padding','compact','TileSpacing','compact');
nexttile; hold on; grid on;
C=lines(3);
for ph=1:3, idx=(bs.phase==ph); plot3(bs.x(idx)/1000,bs.y(idx)/1000,bs.z(idx)/1000,'.','Color',C(ph,:)); end
set(gca,'XDir','reverse'); xlabel('x (km)'); ylabel('y (km)'); zlabel('z (km)'); view(135,25); title('Trajectoire');
nexttile; hold on; grid on; plot(bs.t, 100*bo.throttle); yline(95,'--r'); xlabel('t'); ylabel('Throttle (%)'); title('Throttle');
nexttile; hold on; grid on; plot(bs.t, max(bo.m-params.m_dry,0)/1000); xlabel('t'); ylabel('Propellant (t)'); title('Prop restant');
nexttile; hold on; grid on; plot(bs.t, bs.vx, bs.t, bs.vy, bs.t, bs.vz); yline(0,'--k'); legend('vx','vy','vz'); title('Vitesses');

%% ===================== FONCTIONS =====================

function [ok,dv,thrmax] = score_run(s, sim, out, v_td, THR_MAX_OK)
    % Echelles pour le 0.3%
    Sx=max([abs(s.vx0),abs(s.vx1_t),300]);
    Sy=max([abs(s.vy1_t),100]);
    Sz=max([abs(s.vz1_t),abs(s.vz2_t),20]);
    ok = (abs(sim.vx(end)) <= 0.003*Sx) && ...
         (abs(sim.vy(end)) <= 0.003*Sy) && ...
         (abs(sim.vz(end)-v_td) <= 0.003*Sz) && ...
         (max(out.throttle) <= THR_MAX_OK) && ...
         all(max(out.m - getfielddef(struct(), 'm_dry', 0) - 0, 0)); %#ok<NASGU>
    % NB: on impose prop restant > 0 via masse(out)
    prop_ok = all(max(out.m -  getfielddef(struct('m_dry',0),'m_dry',0),0)(1:end-1) > 0);
    ok = ok && prop_ok;
    dv = out.dV; thrmax = max(out.throttle);
end

function y = vary_pct(x,p), y = x*(1 + p*(2*rand-1)); end

function [Tgo1,Tgo2] = phase_times(s)
    Tgo1 = max(10, (s.x1_t - s.x0) / (0.5*(s.vx0 + s.vx1_t)));
    Tgo2 = max(10, (s.x2_t - s.x1_t) / (0.5*(s.vx1_t + s.vx2_t)));
end

function sim = simulate_case(S, params, dt)
% === Ton intégrateur original, inchangé dans l’esprit ===
g_moon=params.g_moon; clip=@(u,umin,umax) max(min(u,umax),umin);
% ---- cœffs
    function [c1,c2]=braking_coeffs(r0,v0,rt,vt,tgo)
        c1=(-2*(vt+2*v0))/tgo + 6*(rt-r0)/(tgo^2);
        c2=( 6*(vt+v0))/(tgo^2) - 12*(rt-r0)/(tgo^3);
    end
    function [c0,c1,c2]=approach_coeffs(r0,v0,rt,vt,at,tgo)
        c0 = at - 6*(vt+v0)/tgo + 12*(rt - r0)/(tgo^2);
        c1 = -6*at/tgo + 6*(5*vt + 3*v0)/(tgo^2) - 48*(rt - r0)/(tgo^3);
        c2 =  6*at/(tgo^2) - 12*(2*vt + v0)/(tgo^3) + 36*(rt - r0)/(tgo^4);
    end

% ---- init
t=0; x=S.x0; y=S.y0; z=S.z0; vx=S.vx0; vy=S.vy0; vz=S.vz0;
t_all=t; x_all=x; y_all=y; z_all=z; vx_all=vx; vy_all=vy; vz_all=vz;
ax_all=0; ay_all=0; az_all=0; phase_all=0;

% ---- PHASE 1
Tgo1 = max(10, (S.x1_t - S.x0) / (0.5*(S.vx0 + S.vx1_t)));
tgo=Tgo1;
while (z > S.z1_t)
    [c1x,~]=braking_coeffs(x,vx,S.x1_t,S.vx1_t,tgo);
    [c1y,~]=braking_coeffs(y,vy,S.y1_t,S.vy1_t,tgo);
    [c1z,~]=braking_coeffs(z,vz,S.z1_t,S.vz1_t,tgo);
    ax_cmd=c1x; ay_cmd=c1y; az_cmd=c1z;
    vx=vx+ax_cmd*dt; vy=vy+ay_cmd*dt; vz=vz+(az_cmd-g_moon)*dt;
    x=x+vx*dt; y=y+vy*dt; z=z+vz*dt;
    t=t+dt; tgo=tgo-dt;
    t_all(end+1,1)=t; x_all(end+1,1)=x; y_all(end+1,1)=y; z_all(end+1,1)=z;
    vx_all(end+1,1)=vx; vy_all(end+1,1)=vy; vz_all(end+1,1)=vz;
    ax_all(end+1,1)=ax_cmd; ay_all(end+1,1)=ay_cmd; az_all(end+1,1)=az_cmd; phase_all(end+1,1)=1;
    if z<=0, break; end
end
if z<=0, finalize(); return; end

% ---- PHASE 2
Tgo2 = max(10, (S.x2_t - S.x1_t) / (0.5*(S.vx1_t + S.vx2_t)));
tgo=Tgo2;
while (z > S.z2_t)
    [c0x,~,~]=approach_coeffs(x,vx,S.x2_t,S.vx2_t,S.ax2_t,tgo);
    [c0y,~,~]=approach_coeffs(y,vy,S.y2_t,S.vy2_t,S.ay2_t,tgo);
    [c0z,~,~]=approach_coeffs(z,vz,S.z2_t,S.vz2_t,S.az2_t,tgo);
    ax_cmd=c0x; ay_cmd=c0y; az_cmd=c0z;
    vx=vx+ax_cmd*dt; vy=vy+ay_cmd*dt; vz=vz+(az_cmd-g_moon)*dt;
    x=x+vx*dt; y=y+vy*dt; z=z+vz*dt;
    t=t+dt; tgo=tgo-dt;
    t_all(end+1,1)=t; x_all(end+1,1)=x; y_all(end+1,1)=y; z_all(end+1,1)=z;
    vx_all(end+1,1)=vx; vy_all(end+1,1)=vy; vz_all(end+1,1)=vz;
    ax_all(end+1,1)=ax_cmd; ay_all(end+1,1)=ay_cmd; az_all(end+1,1)=az_cmd; phase_all(end+1,1)=2;
    if z<=0, break; end
end
if z<=0, finalize(); return; end

% ---- PHASE 3 (vertical + correcteurs XY) — mêmes choix que chez toi
Kxy=0.8; ax_max=2.0; ay_max=2.0; daz_max=0.6*g_moon;
az_nom=1.2*g_moon; az_max=az_nom+daz_max; a_up_max=max(az_max-g_moon,0.1);
alpha_f=0.6; az_cmd_filt=az_nom;
while z>0
    if z>50
        vx_lim=10; vy_lim=10;
        ax_cmd=(abs(vx)>vx_lim)*(-Kxy*(abs(vx)-vx_lim)*sign(vx));
        ay_cmd=(abs(vy)>vy_lim)*(-Kxy*(abs(vy)-vy_lim)*sign(vy));
    else
        band=0.1;
        ax_cmd=(vx> band)*(-Kxy*(vx-band)) + (vx<-band)*(-Kxy*(vx+band));
        ay_cmd=(vy> band)*(-Kxy*(vy-band)) + (vy<-band)*(-Kxy*(vy+band));
    end
    ax_cmd=max(min(ax_cmd,ax_max),-ax_max);
    ay_cmd=max(min(ay_cmd,ay_max),-ay_max);

    v_env=-sqrt(max(v_td^2 + 2*a_up_max*max(z,0),0));
    if     z>200, v_ref=v_env;
    elseif z>50,  v_ref=max(v_env,-2);
    elseif z>5,   v_ref=max(v_env,-1);
    else          v_ref=max(v_env, v_td);
    end
    if     z>200, tau=12; elseif z>100, tau=6; elseif z>50, tau=4;
    elseif z>20,  tau=2;  elseif z>5,  tau=1.5; else, tau=2; end

    a_net_des=(v_ref - vz)/tau;
    az_cmd_raw=g_moon + a_net_des; az_cmd_raw=max(min(az_cmd_raw,az_max),0);
    az_cmd=alpha_f*az_cmd_filt + (1-alpha_f)*az_cmd_raw; az_cmd_filt=az_cmd;

    vx=vx+ax_cmd*dt; vy=vy+ay_cmd*dt; vz=vz+(az_cmd-g_moon)*dt;
    x=x+vx*dt; y=y+vy*dt; z=z+vz*dt; t=t+dt;

    t_all(end+1,1)=t; x_all(end+1,1)=x; y_all(end+1,1)=y; z_all(end+1,1)=z;
    vx_all(end+1,1)=vx; vy_all(end+1,1)=vy; vz_all(end+1,1)=vz;
    ax_all(end+1,1)=ax_cmd; ay_all(end+1,1)=ay_cmd; az_all(end+1,1)=az_cmd; phase_all(end+1,1)=3;
end
if z_all(end)<0, z_all(end)=0; end
finalize();

    function finalize()
        sim.t=t_all; sim.x=x_all; sim.y=y_all; sim.z=z_all;
        sim.vx=vx_all; sim.vy=vy_all; sim.vz=vz_all;
        sim.ax=ax_all; sim.ay=ay_all; sim.az=az_all; sim.phase=phase_all;
        amag=sqrt(sim.ax.^2 + sim.ay.^2 + sim.az.^2);
        sim.dv_total = trapz(sim.t, amag);
    end
end

function out = thrust_from_traj(t, V, params)
    if size(V,2)==2, V=[V, zeros(size(V,1),1)]; end
    g=params.g_moon; Isp=params.Isp; g0=params.g0; Tmax=params.Tmax; m0=params.m0; m_dry=params.m_dry;
    vx=V(:,1); vy=V(:,2); vz=V(:,3);
    ax=gradient(vx,t); ay=gradient(vy,t); az=gradient(vz,t);
    a_cmd=[ax, ay, az + g]; a_cmd(:,3)=max(a_cmd(:,3),0);
    amag=sqrt(sum(a_cmd.^2,2));
    m = m0 .* exp(-cumtrapz(t, amag./(Isp*g0))); if m_dry>0, m=max(m,m_dry); end
    T_mag = m .* amag; throttle = T_mag / Tmax;
    T_vec = a_cmd.*m; Tx=T_vec(:,1); Ty=T_vec(:,2); Tz=T_vec(:,3);
    tiltdeg = atan2d(hypot(Tx,Ty), max(Tz,0));
    out.T_vec=T_vec; out.T_mag=T_mag; out.throttle=throttle; out.m=m;
    out.dV=trapz(t,amag); out.m_prop=m0-m(end); out.a_cmd=a_cmd; out.tiltdeg=tiltdeg;
    out.flags.sat_throttle = throttle>1; out.flags.vert_negative = Tz<0; out.flags.over_tilt = tiltdeg>params.tilt_max_deg;
end

% petite util
function v = getfielddef(s,name,def), if isfield(s,name)&&~isempty(s.(name)), v=s.(name); else, v=def; end, end
